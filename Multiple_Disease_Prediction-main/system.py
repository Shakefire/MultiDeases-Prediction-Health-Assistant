

import pickle
import streamlit as st
from streamlit_option_menu import option_menu
import shap
import numpy as np
import pandas as pd
from fpdf import FPDF
import base64
from datetime import datetime
from shap import LinearExplainer, TreeExplainer, KernelExplainer

# Initialize session state
if 'health_points' not in st.session_state:
    st.session_state.health_points = 0
if 'patient_name' not in st.session_state:
    st.session_state.patient_name = ""

# Load models
diabetes_model = pickle.load(open('Models/diabetes.pkl', 'rb'))
heart_disease_model = pickle.load(open('Models/heart.pkl', 'rb'))
BreastCancer_model = pickle.load(open('Models/Breastcancer.pkl', 'rb'))
liver_model = pickle.load(open('Models/liver.pkl', 'rb'))
parkinsons_model = pickle.load(open('Models/parkinsons_model.sav', 'rb'))

# --- Helper Functions ---


def convert_to_numeric(value, default_value=0):
    """Convert input to numeric safely"""
    try:
        return float(value)
    except ValueError:
        return default_value


# def generate_pdf_report(disease, prediction, confidence, features, recommendations):
#     """Generate downloadable PDF report"""
#     pdf = FPDF()
#     pdf.add_page()
#     pdf.set_font("Arial", size=12)

#     # Report Header
#     pdf.cell(200, 10, txt="HEALTH DIAGNOSTIC REPORT", ln=1, align='C')
#     pdf.cell(200, 10, txt="--------------------------------", ln=1, align='C')

#     # Patient Info
#     pdf.cell(
#         200, 10, txt=f"Patient Name: {st.session_state.patient_name}", ln=1)
#     pdf.cell(
#         200, 10, txt=f"Report Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=1)

#     # Diagnosis Section
#     pdf.set_font("Arial", 'B', 14)
#     pdf.cell(200, 10, txt=f"Diagnosis: {disease} Risk Assessment", ln=1)
#     pdf.set_font("Arial", size=12)
#     risk_level = "High Risk" if prediction == 1 else "Low Risk"
#     pdf.cell(200, 10, txt=f"Risk Level: {risk_level}", ln=1)
#     pdf.cell(200, 10, txt=f"Confidence Score: {confidence:.2f}%", ln=1)

#     # Key Factors
#     pdf.cell(200, 10, txt="Key Risk Factors:", ln=1)
#     for factor, value in features.items():
#         pdf.cell(200, 10, txt=f"- {factor}: {value}", ln=1)

#     # Recommendations
#     pdf.set_font("Arial", 'B', 14)
#     pdf.cell(200, 10, txt="Recommended Actions:", ln=1)
#     pdf.set_font("Arial", size=12)
#     for rec in recommendations:
#         pdf.cell(200, 10, txt=f"- {rec}", ln=1)

#     # Footer
#     pdf.set_font("Arial", 'I', 10)
#     pdf.cell(200, 10, txt="Generated by HealthPredict AI System", ln=1, align='C')

#     return pdf.output(dest='S')
def generate_pdf_report(disease, prediction, confidence, features, recommendations):
    """Generate downloadable PDF report"""
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Report Header
    pdf.cell(200, 10, txt="HEALTH DIAGNOSTIC REPORT", ln=1, align='C')
    pdf.cell(200, 10, txt="--------------------------------", ln=1, align='C')

    # Patient Info
    pdf.cell(200, 10, txt=f"Patient Name: {st.session_state.patient_name}", ln=1)
    pdf.cell(200, 10, txt=f"Report Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=1)

    # Diagnosis Section
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt=f"Diagnosis: {disease} Risk Assessment", ln=1)
    pdf.set_font("Arial", size=12)
    risk_level = "High Risk" if prediction == 1 else "Low Risk"
    pdf.cell(200, 10, txt=f"Risk Level: {risk_level}", ln=1)
    pdf.cell(200, 10, txt=f"Confidence Score: {confidence:.2f}%", ln=1)

    # Key Factors
    pdf.cell(200, 10, txt="Key Risk Factors:", ln=1)
    for factor, value in features.items():
        pdf.cell(200, 10, txt=f"- {factor}: {value}", ln=1)

    # Recommendations
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt="Recommended Actions:", ln=1)
    pdf.set_font("Arial", size=12)
    for rec in recommendations:
        pdf.cell(200, 10, txt=f"- {rec}", ln=1)

    # Footer
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(200, 10, txt="Generated by HafsatPredict Health System", ln=1, align='C')

    # Return as bytes
    return pdf.output(dest='S').encode('latin1')  # Ensure the data returned is bytes

def create_download_link(pdf_data, filename):
    """Generate download link for PDF"""
    b64 = base64.b64encode(pdf_data).decode()
    return f'<a href="data:application/octet-stream;base64,{b64}" download="{filename}">Download Full Report</a>'


def explain_prediction(model, input_data, feature_names):
    """Improved SHAP explanation with better diagnostics"""
    import numpy as np
    import pandas as pd

    # Convert to proper numpy array format
    input_array = np.array(input_data).reshape(1, -1)

    try:
        # For linear models (Logistic Regression)
        if hasattr(model, 'coef_'):
            explainer = LinearExplainer(model, input_array)
            shap_values = explainer.shap_values(input_array)
            impacts = shap_values[0]

        # For tree-based models (Random Forest, etc.)
        elif hasattr(model, 'feature_importances_'):
            explainer = TreeExplainer(model)
            shap_values = explainer.shap_values(input_array)
            impacts = shap_values[0] if isinstance(
                shap_values, list) else shap_values[0][0]

        # For neural networks or other models
        else:
            background = shap.kmeans(input_array, 1)
            explainer = KernelExplainer(model.predict, background)
            shap_values = explainer.shap_values(input_array)
            impacts = shap_values[0]

        return pd.DataFrame({
            "Feature": feature_names,
            "Impact": impacts
        }).sort_values("Impact", key=abs, ascending=False)

    except Exception as e:
        st.error(f"Explanation failed: {str(e)}")
        # Fallback to showing feature importances if available
        if hasattr(model, 'feature_importances_'):
            return pd.DataFrame({
                "Feature": feature_names,
                "Impact": model.feature_importances_
            })
        elif hasattr(model, 'coef_'):
            return pd.DataFrame({
                "Feature": feature_names,
                "Impact": model.coef_[0]
            })
        return pd.DataFrame({
            "Feature": feature_names,
            "Impact": ["N/A"]*len(feature_names)
        })


def update_gamification():
    """Update health points with visual feedback"""
    st.session_state.health_points += 10
    st.balloons()


# --- Streamlit UI ---
with st.sidebar:
    st.session_state.patient_name = st.text_input(
        "Patient Name", "Hafsat Ibrahim Matori", key="patient_name_input")
    selected = option_menu('Multiple Disease Prediction System',
                           ['Diabetes Prediction', 'Heart Disease Prediction',
                            'Breast Cancer Prediction', 'Liver Disease Prediction',
                            'Parkinsons Prediction'],
                           default_index=0)

# --- Diabetes Prediction ---
if selected == 'Diabetes Prediction':
    st.title('Diabetes Prediction + Health Insights')

    # Input fields with unique keys
    col1, col2 = st.columns(2)
    with col1:
        Pregnancies = st.number_input('Pregnancies', 0, 20, 0, key="diab_preg")
        Glucose = st.number_input(
            'Glucose Level', 50, 300, 120, key="diab_gluc")
        BloodPressure = st.number_input(
            'Blood Pressure', 60, 200, 80, key="diab_bp")
    with col2:
        BMI = st.number_input('BMI', 10.0, 50.0, 25.0, key="diab_bmi")
        Age = st.number_input('Age', 1, 120, 30, key="diab_age")
        DiabetesPedigreeFunction = st.number_input(
            'Diabetes Pedigree', 0.0, 2.0, 0.5, key="diab_dpf")

    if st.button('Predict Diabetes Risk', key="diab_btn"):
        # Prepare input data
        input_data = [[Pregnancies, Glucose, BloodPressure,
                       0, 0, BMI, DiabetesPedigreeFunction, Age]]

        # Get prediction and confidence
        prediction = diabetes_model.predict(input_data)[0]
        try:
            confidence = max(diabetes_model.predict_proba(input_data)[0]) * 100
        except:
            confidence = 85.0  # Default if model doesn't support probabilities

        # Generate report content
        features = {
            "Glucose Level": f"{Glucose} mg/dL {'(High)' if Glucose > 140 else '(Normal)'}",
            "BMI": f"{BMI} {'(Overweight)' if BMI > 25 else '(Healthy)'}",
            "Age": f"{Age} years",
            "Blood Pressure": f"{BloodPressure} mmHg"
        }

        recommendations = [
            "Maintain glucose levels below 140 mg/dL",
            "Exercise for 30 minutes daily",
            "Annual diabetic screening recommended" if prediction == 1 else "Maintain current lifestyle"
        ]

        # Display results
        st.subheader("Results")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Risk Level", "High Risk" if prediction ==
                      1 else "Low Risk")
        with col2:
            st.metric("Confidence", f"{confidence:.1f}%")

        # Downloadable PDF
        pdf_data = generate_pdf_report(
            "Diabetes",
            prediction,
            confidence,
            features,
            recommendations
        )
        st.markdown(create_download_link(
            pdf_data, "Diabetes_Report.pdf"), unsafe_allow_html=True)

        # Explainable AI
        st.subheader("ðŸ” Key Influencing Factors")
        shap_df = explain_prediction(
            diabetes_model,
            input_data,
            ["Pregnancies", "Glucose", "BP", "SkinThickness",
                "Insulin", "BMI", "DPF", "Age"]
        )
        st.dataframe(shap_df.head(3))

        # Gamification
        if prediction == 1:
            st.subheader("ðŸ’ª Prevention Challenge")
            if st.checkbox("Log today's healthy meal", key="diab_chk1"):
                update_gamification()
            st.write(f"ðŸ† Health Points: {st.session_state.health_points}")

# --- Heart Disease Prediction ---
if selected == 'Heart Disease Prediction':
    st.title('Heart Disease Prediction + Insights')

    # Input fields with unique keys
    col1, col2 = st.columns(2)
    with col1:
        age = st.number_input('Age', 1, 120, 50, key="heart_age")
        trestbps = st.number_input('Resting BP', 80, 200, 120, key="heart_bp")
        thalach = st.number_input(
            'Max Heart Rate', 70, 220, 150, key="heart_hr")
    with col2:
        chol = st.number_input('Cholesterol', 100, 600, 200, key="heart_chol")
        oldpeak = st.number_input(
            'ST Depression', 0.0, 6.0, 1.0, key="heart_st")
        cp = st.selectbox('Chest Pain Type', [0, 1, 2, 3], key="heart_cp")

    if st.button('Predict Heart Disease Risk', key="heart_btn"):
        # Prepare input data with all 13 features
        input_features = [
            age, 1, cp, trestbps, chol, 0, 0, thalach, 0, oldpeak, 1, 0, 2
        ]
        input_array = np.array(input_features).reshape(1, -1)

        # Get prediction
        prediction = heart_disease_model.predict(input_array)[0]

        # Get confidence score
        try:
            confidence = max(
                heart_disease_model.predict_proba(input_array)[0]) * 100
        except:
            confidence = 80.0  # Default confidence if predict_proba unavailable

        # Generate SHAP explanation
        try:
            # First try TreeExplainer for tree-based models
            explainer = shap.TreeExplainer(heart_disease_model)
            shap_values = explainer.shap_values(input_array)

            # Handle both binary and multi-class outputs
            if isinstance(shap_values, list):
                impacts = shap_values[1][0] if len(
                    shap_values) > 1 else shap_values[0][0]
            else:
                impacts = shap_values[0]

            feature_names = [
                "Age", "Sex", "Chest Pain", "Resting BP", "Cholesterol",
                "Fasting BS", "Resting ECG", "Max HR", "Exercise Angina",
                "ST Depression", "Slope", "Major Vessels", "Thalassemia"
            ]

            impact_df = pd.DataFrame({
                "Feature": feature_names,
                "Impact": impacts
            }).sort_values("Impact", key=abs, ascending=False)

        except Exception as e:
            # st.warning(f"Detailed explanation unavailable: {str(e)}")
            st.warning("Detailed explanation unavailable:")
            # Fallback to model coefficients if available
            if hasattr(heart_disease_model, 'coef_'):
                impact_df = pd.DataFrame({
                    "Feature": feature_names,
                    "Impact": heart_disease_model.coef_[0]
                })
            else:
                impact_df = pd.DataFrame({
                    "Feature": ["Age", "Cholesterol", "Resting BP", "Max HR"],
                    # Example values if all else fails
                    "Impact": [0.5, 0.3, 0.4, -0.6]
                })

        # Generate report content
        features = {
            "Age": f"{age} years",
            "Cholesterol": f"{chol} mg/dL {'(High)' if chol > 200 else '(Normal)'}",
            "Resting BP": f"{trestbps} mmHg",
            "Max Heart Rate": f"{thalach} bpm"
        }

        recommendations = [
            "Reduce sodium intake" if prediction == 1 else "Maintain current diet",
            "Cardio exercise 3x weekly",
            "Stress management techniques"
        ]

        # Display results
        st.subheader("Results")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Risk Level", "High Risk" if prediction ==
                      1 else "Low Risk")
        with col2:
            st.metric("Confidence", f"{confidence:.1f}%")

        # Downloadable PDF
        pdf_data = generate_pdf_report(
            "Heart Disease",
            prediction,
            confidence,
            features,
            recommendations
        )
        st.markdown(create_download_link(
            pdf_data, "Heart_Report.pdf"), unsafe_allow_html=True)

        # Explainable AI
        st.subheader("ðŸ” Top Risk Factors")

        # Show both raw values and impacts
        tab1, tab2 = st.tabs(["Feature Values", "Impact Analysis"])

        with tab1:
            st.dataframe(pd.DataFrame({
                "Feature": ["Age", "Resting BP", "Cholesterol", "Max HR"],
                "Value": [age, trestbps, chol, thalach]
            }))

        with tab2:
            st.dataframe(
                impact_df.style.format({"Impact": "{:.4f}"}),
                height=400
            )
            st.caption(
                "Positive values increase heart disease risk, negative values decrease risk")

        # Gamification
        if prediction == 1:
            st.subheader("â¤ï¸ Heart Health Challenge")
            if st.checkbox("Complete 15-minute walk today", key="heart_chk1"):
                update_gamification()
            st.write(f"ðŸ† Health Points: {st.session_state.health_points}")

# --- Parkinson's Prediction ---
if selected == 'Parkinsons Prediction':
    st.title("Parkinson's Disease Prediction")

    # Input fields with unique keys
    col1, col2 = st.columns(2)
    with col1:
        fo = st.number_input('MDVP:Fo(Hz)', 80.0, 260.0, 150.0, key="park_fo")
        spread1 = st.number_input(
            'Spread1', -10.0, 0.0, -5.0, key="park_spread1")
        PPE = st.number_input('PPE', 0.0, 1.0, 0.2, key="park_ppe")
    with col2:
        HNR = st.number_input('HNR', 0.0, 30.0, 20.0, key="park_hnr")
        DFA = st.number_input('DFA', 0.5, 0.9, 0.7, key="park_dfa")

    if st.button("Predict Parkinson's Risk", key="park_btn"):
        # Prepare input data (using key features only)
        input_data = [[fo, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, HNR, 0, DFA, spread1, 0, 0, PPE]]

        # Get prediction and confidence
        prediction = parkinsons_model.predict(input_data)[0]
        confidence = 75.0  # Placeholder if no proba available

        # Generate report content
        features = {
            "Vocal Frequency (Fo)": f"{fo} Hz",
            "HNR (Voice Stability)": f"{HNR} {'(Normal)' if HNR > 20 else '(Concerning)'}",
            "PPE (Nonlinear Measure)": f"{PPE:.2f}"
        }

        recommendations = [
            "Neurological consultation recommended" if prediction == 1 else "No immediate action needed",
            "Voice monitoring exercises",
            "Annual movement screening"
        ]

        # Display results
        st.subheader("Results")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Risk Level", "High Risk" if prediction ==
                      1 else "Low Risk")
        with col2:
            st.metric("Confidence", f"{confidence:.1f}%")

        # Downloadable PDF
        pdf_data = generate_pdf_report(
            "Parkinson's Disease",
            prediction,
            confidence,
            features,
            recommendations
        )
        st.markdown(create_download_link(
            pdf_data, "Parkinsons_Report.pdf"), unsafe_allow_html=True)

        # Explainable AI
        st.subheader("ðŸ” Key Indicators")
        st.write("Top features contributing to prediction:")
        st.json({
            "Vocal Frequency (Fo)": f"{fo} Hz",
            "Pitch Variation (PPE)": f"{PPE:.2f}",
            "Voice Stability (HNR)": HNR
        })

        # Gamification
        if prediction == 1:
            st.subheader("ðŸ§  Brain Health Challenge")
            if st.checkbox("Complete daily vocal exercise", key="park_chk1"):
                update_gamification()
            st.write(f"ðŸ† Health Points: {st.session_state.health_points}")

# --- Breast Cancer Prediction ---
if selected == 'Breast Cancer Prediction':
    st.title('Breast Cancer Prediction')

    # Input fields with unique keys
    col1, col2 = st.columns(2)
    with col1:
        radius_mean = st.number_input(
            'Radius Mean', 5.0, 30.0, 15.0, key="bc_rad")
        texture_mean = st.number_input(
            'Texture Mean', 5.0, 40.0, 20.0, key="bc_text")
        perimeter_mean = st.number_input(
            'Perimeter Mean', 40.0, 200.0, 100.0, key="bc_perim")
        smoothness_mean = st.number_input(
            'Smoothness', 0.0, 0.5, 0.2, key="bc_som")

    with col2:
        concave_points_mean = st.number_input(
            'Concave Points', 0.0, 0.2, 0.05, key="bc_concave")
        concavity_mean = st.number_input(
            'Concavity', 0.0, 0.5, 0.2, key="bc_mean")
        area_mean = st.number_input(
            'Area', 0.0, 0.5, 0.2, key="bc_area")
        compactness_mean = st.number_input(
            'Compactness', 0.0, 0.5, 0.2, key="bc_comp")



    if st.button('Predict Breast Cancer Risk', key="bc_btn"):
        # Prepare input data with proper feature scaling
        input_features = [
            radius_mean,texture_mean,perimeter_mean, area_mean, smoothness_mean,
            compactness_mean,concavity_mean,concave_points_mean
        ]
        input_array = np.array(input_features).reshape(1, -1)

        # Get prediction
        prediction = BreastCancer_model.predict(input_array)[0]

        # Get confidence score
        try:
            confidence = max(
                BreastCancer_model.predict_proba(input_array)[0]) * 100
        except:
            confidence = 85.0  # Default confidence if predict_proba unavailable

        # Generate SHAP explanation
        try:
            # First try TreeExplainer for tree-based models
            explainer = shap.TreeExplainer(BreastCancer_model)
            shap_values = explainer.shap_values(input_array)

            # Handle both binary and multi-class outputs
            if isinstance(shap_values, list):
                impacts = shap_values[1][0] if len(
                    shap_values) > 1 else shap_values[0][0]
            else:
                impacts = shap_values[0]

            feature_names = [
                "Radius Mean", "Texture Mean", "Perimeter Mean",
                "Area Mean", "Smoothness", "Compactness",
                "Concavity", "Concave Points", "Symmetry",
                "Fractal Dim"
            ]

            impact_df = pd.DataFrame({
                "Feature": feature_names,
                "Impact": impacts
            }).sort_values("Impact", key=abs, ascending=False)

        except Exception as e:
            st.warning(f"Detailed explanation unavailable: {str(e)}")
            # Fallback to model coefficients if available
            if hasattr(BreastCancer_model, 'coef_'):
                impact_df = pd.DataFrame({
                    "Feature": feature_names,
                    "Impact": BreastCancer_model.coef_[0]
                })
            else:
                impact_df = pd.DataFrame({
                    "Feature": ["Radius", "Texture", "Concave Points"],
                    # Example values if all else fails
                    "Impact": [0.5, 0.3, 0.8]
                })

        # Generate report content
        features = {
            "Tumor Radius": f"{radius_mean:.1f} mm",
            "Texture": f"{texture_mean:.1f}",
            "Irregularity (Concave Points)": f"{concave_points_mean:.3f}"
        }

        recommendations = [
            "Schedule mammogram" if prediction == 1 else "Continue regular screenings",
            "Monthly self-exams",
            "Consult oncologist if risk is high"
        ]

        # Display results
        st.subheader("Results")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Risk Level", "High Risk" if prediction ==
                      1 else "Low Risk")
        with col2:
            st.metric("Confidence", f"{confidence:.1f}%")

        # Downloadable PDF
        pdf_data = generate_pdf_report(
            "Breast Cancer",
            prediction,
            confidence,
            features,
            recommendations
        )
        st.markdown(create_download_link(
            pdf_data, "Breast_Cancer_Report.pdf"), unsafe_allow_html=True)

        # Explainable AI
        st.subheader("ðŸ” Key Tumor Characteristics")

        # Show both raw values and impacts
        tab1, tab2 = st.tabs(["Feature Values", "Impact Analysis"])

        with tab1:
            st.dataframe(pd.DataFrame({
                "Feature": ["Radius", "Texture", "Concave Points"],
                "Value": [radius_mean, texture_mean, concave_points_mean]
            }))

        with tab2:
            st.dataframe(
                impact_df.style.format({"Impact": "{:.4f}"}),
                height=400
            )
            st.caption(
                "Positive values increase cancer risk, negative values decrease risk")

        # Gamification
        if prediction == 1:
            st.subheader("ðŸ’– Prevention Challenge")
            if st.checkbox("Perform breast self-exam this week", key="bc_chk1"):
                update_gamification()
            st.write(f"ðŸ† Health Points: {st.session_state.health_points}")
# --- Liver Disease Prediction ---
if selected == 'Liver Disease Prediction':
    st.title('Liver Disease Prediction')

    # Input fields with unique keys
    col1, col2 = st.columns(2)
    with col1:
        age = st.number_input('Age', 10, 100, 45, key="liver_age")
        total_bilirubin = st.number_input(
            'Total Bilirubin', 0.1, 30.0, 1.0, key="liver_bili")
        alkaline_phosphotase = st.number_input(
            'Alkaline Phosphotase', 50, 1000, 150, key="liver_alk")
    with col2:
        albumin = st.number_input('Albumin', 1.0, 10.0, 4.0, key="liver_alb")
        albumin_globulin_ratio = st.number_input(
            'A/G Ratio', 0.1, 3.0, 1.0, key="liver_ag")

    if st.button('Predict Liver Disease Risk', key="liver_btn"):
        # Prepare input data
        input_data = [[age, 1, total_bilirubin, 0, alkaline_phosphotase,
                       0, 0, 0, albumin, albumin_globulin_ratio]]

        # Get prediction and confidence
        prediction = liver_model.predict(input_data)[0]
        confidence = 80.0  # Placeholder

        # Generate report content
        features = {
            "Bilirubin": f"{total_bilirubin} mg/dL {'(High)' if total_bilirubin > 1.2 else '(Normal)'}",
            "Albumin": f"{albumin} g/dL {'(Low)' if albumin < 3.4 else '(Healthy)'}",
            "Alkaline Phosphatase": f"{alkaline_phosphotase} U/L"
        }

        recommendations = [
            "Limit alcohol consumption" if prediction == 1 else "Maintain healthy diet",
            "Liver function tests recommended",
            "Hydration and exercise"
        ]

        # Display results
        st.subheader("Results")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Risk Level", "High Risk" if prediction ==
                      1 else "Low Risk")
        with col2:
            st.metric("Confidence", f"{confidence:.1f}%")

        # Downloadable PDF
        pdf_data = generate_pdf_report(
            "Liver Disease",
            prediction,
            confidence,
            features,
            recommendations
        )
        st.markdown(create_download_link(
            pdf_data, "Liver_Report.pdf"), unsafe_allow_html=True)

        # Explainable AI
        st.subheader("ðŸ” Liver Health Indicators")
        st.dataframe(pd.DataFrame({
            "Test": ["Bilirubin", "Albumin", "Alk. Phos"],
            "Your Value": [total_bilirubin, albumin, alkaline_phosphotase],
            "Normal Range": ["0.1-1.2 mg/dL", "3.4-5.4 g/dL", "44-147 U/L"]
        }))

        # Gamification
        if prediction == 1:
            st.subheader("ðŸ Liver Health Challenge")
            if st.checkbox("Drink 8 glasses of water today", key="liver_chk1"):
                update_gamification()
            st.write(f"ðŸ† Health Points: {st.session_state.health_points}")

